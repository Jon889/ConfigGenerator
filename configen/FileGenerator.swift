//
//  FileGenerator.swift
//  configen
//
//  Created by Dónal O'Brien on 11/08/2016.
//  Copyright © 2016 The App Business. All rights reserved.
//

import Foundation

struct FileGenerator {
  
  let optionsParser: OptionsParser
  
  var autoGenerationComment: String {
    return """
    // auto-generated by \(optionsParser.appName)\n// to add or remove properties, edit the mapping file: '\(optionsParser.inputHintsFilePath)'.\n// README: https://github.com/theappbusiness/ConfigGenerator/blob/master/README.md\n\n
    """
  }
  
  func generateHeaderFile(withTemplate template: HeaderTemplate) {
    
    var headerBodyContent = ""
    optionsParser.sortedHints.forEach { hint in
      let headerLine = methodDeclaration(for: hint, template: template)
      headerBodyContent.append("\n" + headerLine + ";" + "\n")
    }
    
    var headerBody = template.headerBody
    headerBody.replace(token: template.bodyToken, withString: headerBodyContent)
    
    do {
      let headerOutputString = autoGenerationComment + template.headerImportStatements + headerBody
      try headerOutputString.write(toFile: template.outputHeaderFileName, atomically: true, encoding: String.Encoding.utf8)
    } catch {
      fatalError("Failed to write to file at path \(template.outputHeaderFileName)")
    }
    
  }
  
  func generateImplementationFile(withTemplate template: ImplementationTemplate) {
    var implementationBodyContent = ""
    optionsParser.sortedHints.forEach { hint in
      let implementationLine = methodImplementation(for: hint, template: template)
      implementationBodyContent.append("\n" + implementationLine + "\n")
    }
    
    var implementationBody = template.implementationBody
    implementationBody.replace(token: template.bodyToken, withString: implementationBodyContent)
    
    do {
      let implementationOutputString = autoGenerationComment + template.implementationImportStatements + implementationBody
      try implementationOutputString.write(toFile: template.outputImplementationFileName, atomically: true, encoding: String.Encoding.utf8)
    } catch {
      fatalError("Failed to write to file at path \(template.outputImplementationFileName)")
    }
    
  }
  
  private func methodDeclaration(for hint: OptionsParser.Hint, template: HeaderTemplate) -> String {
    var line: String
    
    switch hint.type {
      case .double:
        line = template.doubleDeclaration
      case .int:
        line = template.integerDeclaration
      case .string:
        line = template.stringDeclaration
      case .bool:
        line = template.booleanDeclaration
      case .url:
        line = template.urlDeclaration
      case .array, .any, .custom:
        line = template.customDeclaration
        line.replace(token: template.customTypeToken, withString: hint.type.description)
    }
    
    line.replace(token: template.variableNameToken, withString: hint.variableName)
    
    return line
  }
  
  private func methodImplementation(for hint: OptionsParser.Hint, template: ImplementationTemplate) -> String {
    guard let value = optionsParser.plistDictionary[hint.variableName] else {
      fatalError("No configuration setting for variable name: \(hint.variableName)")
    }
    
    var line: String
    
    switch hint.type {
      case .double:
        line = template.doubleImplementation
      case .int:
        line = template.integerImplementation
      case .string:
        line = template.stringImplementation
      case .bool:
        guard let value = value as? Bool else { fatalError("Not a bool!") }
        let boolString = value ? template.trueString : template.falseString
        line = template.booleanImplementation
        line.replace(token: template.valueToken, withString: boolString)
      case .url:
        guard let url = URL(string: "\(value)") else { fatalError("Not a URL!") }
        precondition(url.host != nil, "Found URL without host: \(url) for setting: \(hint.variableName)")
        line = template.urlImplementation
      case .array:
        line = template.customImplementation
        line.replace(token: template.variableNameToken, withString: hint.variableName)
        line.replace(token: template.customTypeToken, withString: hint.type.description)
        line.replace(token: template.valueToken, withString: CastUtils.transformArrayToString(hint.type, rawValue: value))
        return line
      case .any, .custom:
        line = template.customImplementation
        line.replace(token: template.customTypeToken, withString: hint.type.description)
    }
    
    line.replace(token: template.variableNameToken, withString: hint.variableName)
    line.replace(token: template.valueToken, withString: "\(value)")
    
    return line
  }
}
